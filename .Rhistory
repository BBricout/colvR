params, # Paramètres fourni en entrée
config){ # Paramètres pour l'optimisation
n <- nrow(Y)
p <- ncol(Y)
R <- ifelse(is.na(Y), 0, 1) # Masque qui met des 0 à la place des données manquantes
Y.na <- ifelse(R == 0, 0, Y)
data <- list(Y = Y.na,
R = R,
X = X,
O = O,
w = w)
out <- nlopt_optimize_rank_cov(data, params, config)
Y.hat <- predict.Y(X, out, n, p)
return(list(init = params, estim = out, Y.hat = Y.hat))
}
Inter.PLNPCA(Y, vecX, O, w, q, params, config)
rm(list=ls())
set.seed("123")
source(file = "~/Documents/PLNmodels/PLNmodels/inst/missing_data/Fonction_PLNPCA_covariables.R")
n = 200 # Nombre d'observation
p = 20 # Nombre de variables
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,n),matrix(rnorm((n*p)*d), nrow = n)) # Matrice de covariables n*d+1
X
X <- cbind(rep(1,n*p),matrix(rnorm((n*p)*d), nrow = n)) # Matrice de covariables n*d+1
np = n*p
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = n)) # Matrice de covariables n*d+1
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*d+1
X
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 3, 1, 1.5, 2)
B <- c(0.5, 3, 1, 1.5, 2, 0.7)
C <- matrix(rnorm(p*d), nrow = p)
C
Z <- X %*% B + W %*% t(C)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
C <- matrix(rnorm(p*q), nrow = p)
Z <- XB + W %*% t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Y
C <- matrix(rnorm(p*q), nrow = p)/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Y
XB
exp(XB)
plot(exp(XB))
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)/p
XB <- VectorToMatrix(X%*%B, n, p)
plot(exp(XB))
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
plot(Y)
Y
plot(Y[,2], Y[,3])
library(lori)
install.packages =("lori")
library(lori)
install.packages =("lori")
install.packages("lori")
## covariates
m1 <- 30 # number of rows
m2 <- 10 # number of columns
K1 <- 2 # number of row covariates
K2 <- 2 # number of column covariates
K3 <- 3 # number of (rowxcolumn) covariates
R <- matrix(rnorm(m1*K1), nrow=m1) # matrix of row covariates
C <- matrix(rnorm(m2*K2), nrow=m2) # matrix of column covariates
E <- matrix(rnorm(m1*m2*K3), nrow=m1*m2) # matrix of  (rowxcolumn) covariates
rm(list=ls())
set.seed("123")
source(file = "~/Documents/PLNmodels/PLNmodels/inst/missing_data/Fonction_PLNPCA_covariables.R")
library(lori)
## covariates
n <- 30 # number of rows
p <- 10 # number of columns
d1 <- 2 # number of row covariates
d2 <- 2 # number of column covariates
d3 <- 3 # number of (rowxcolumn) covariates
R <- matrix(rnorm(m1*K1), nrow=m1) # matrix of row covariates
C <- matrix(rnorm(m2*K2), nrow=m2) # matrix of column covariates
R <- matrix(rnorm(n*d1), nrow=n) # matrix of row covariates
C <- matrix(rnorm(p*d2), nrow=p) # matrix of column covariates
E <- matrix(rnorm(n*p*d3), nrow=n*p) # matrix of  (rowxcolumn) covariates
U <- covmat(n, p, R, C, E)
U <- scale(U)
U
alpha0 <- rep(0,n)
alpha0[1:6] <- 1
beta0 <- rep(0, p)
beta0[1:4] <- 1
n = 200 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
res.lori <- lori(Y, X, lambda1, lambda2)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
res.lori
names(lori)
names(res.lori)
res.lori$epsilon
res.lori$alpha
res.lori$beta
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
res.PLNPCA$estim$B
plot(Y, res.PLNPCA$Y.hat)
plot(Y, res.PLNPCA$Y.hat);abline(0,1)
Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Y
hist(Y)
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
plot(Y, res.PLNPCA$Y.hat); abline(0,1)
res.PLNPCA$estim$B
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
C <- matrix(rnorm(p*q), nrow = p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
n = 200 # Nombre d'observation
p = 5 # Nombre de variables
d = 1 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,n),matrix(rnorm(n*d), nrow = n)) # Matrice de covariables n*d+1
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- matrix(0,d+1,p) # Coefficients des covariables d+1*p
B[1,] <- c(3,2,4,2,3)
B[2,] <- c(0.6, 0.5, 0.4, 0.4, 0.2)
C <- matrix(0, p, q) # Coefficients des variables latentes p*q
C[,1] <- c(0.2, 0.5, 0.4, 0.2, 0.1)
C[,2] <- c(0.4, 0.2, 0.1, 0.3, 0.2)
print(C%*%t(C))
Z <- X %*% B + W %*% t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Y
Y.na <- prodNA(Y, 0.3)
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
config <- PLNPCA_param()$config_optim
# C.init <- matrix(0, p, q)
# M.init <- matrix(0, n, q)
# S.init <- matrix(0, n, q)
#
#
# params <- list(B = B.init, C = C.init, M = M.init, S = S.init)
#
#
# source(file = "~/Documents/PLNmodels/PLNmodels/inst/missing_data/Fonction_PLN_missing_data.R")
#
vecX <- matrix(rnorm(n*p*2), nrow = n*p, ncol = 2)
vecY <- MatrixToVector(Y)
fit <- lm(log(1 + vecY) ~ -1 + vecX)
B.init <- as.matrix(fit$coefficients)
res.vec <- fit$residuals
res.full <- ifelse(is.na(vecY), 0, res.vec)
res.mat <- VectorToMatrix(res.full, n, p)
svdM <- svd(res.mat, nu = q, nv = p)
C.init  <- svdM$v[, 1:q, drop = FALSE] %*% diag(svdM$d[1:q], nrow = q, ncol = q)/sqrt(n)
M.init  <- svdM$u[, 1:q, drop = FALSE] %*% diag(svdM$d[1:q], nrow = q, ncol = q) %*% t(svdM$v[1:q, 1:q, drop = FALSE])
S.init  <- matrix(0.1, n, q)
params <- list(B = B.init, C = C.init, M = M.init, S = S.init)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = vecX, O = O, w = w)
myPCA <- nlopt_optimize_rank_cov(data, params, config)
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
myPCA <- nlopt_optimize_rank_cov(data, params, config)
rm(list=ls())
library(Rcpp)
library(tidyr)
library(dplyr)
library(ggplot2)
library(missForest)
library(PLNmodels)
library(missMDA)
sourceCpp("~/Documents/PLNmodels/PLNmodels/src/optim_rank_cov_inter.cpp")
rm(list=ls())
set.seed("123")
source(file = "~/Documents/PLNmodels/PLNmodels/inst/missing_data/Fonction_PLNPCA_covariables.R")
library(lori)
n = 200 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
lambda1 <- 0.1
lambda2 <- 0.1
res.lori <- lori(Y, X, lambda1, lambda2)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
library(missForest)
summary(Y)
C <- C/sqrt(C)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
C
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
C <- matrix(rnorm(p*q), nrow = p)
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
max(Y)
min(Y)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
n = 500 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
C <- C/p
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
print(max(Y))
C <- scale(C)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/n
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(max(C)-min(C))
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/(max(C)-min(C))
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + W %*% t(C)
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- matrix(rnorm(p*q), nrow = p)
C
Z <- XB + (W %*% t(C))/n
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
Z <- XB + (W %*% t(C))/sqrt(max(W %*% t(C)) - min(W %*% t(C)))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(Y, res.PLNPCA$Y.hat)
data.frame(
fitted   = as.vector(res.PLNPCA$Y.hat),
observed = as.vector(Y)
) %>%
ggplot(aes(x = observed, y = fitted)) +
geom_point(size = .5, alpha =.25 ) +
scale_x_log10(limits = c(1,1000)) +
scale_y_log10(limits = c(1,1000)) +
theme_bw() + annotation_logticks()
res.PLNPCA$estim$B
C <- matrix(rnorm(p*q), nrow = p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
C <- C/sqrt(2*p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
plot(C, res.PLNPCA$estim$C)
C.hat <- res.PLNPCA$estim$C
plot(t(C)%*%C, t(C.hat)%*%C.hat)
t(C)%*%C
plot(C%*%t(C), C.hat%*%t(C.hat))
plot(C%*%t(C), C.hat%*%t(C.hat)); abline(0,1)
n = 5000 # Nombre d'observation
p = 20 # Nombre de variables
np = n*p
d = 5 # Nombre de covariables sans l'intercept
q = 2 # Dimension de l'espace latent
X <- cbind(rep(1,np),matrix(rnorm(np*d), nrow = np)) # Matrice de covariables n*(d+1)
W <-  matrix(rnorm(n*q), nrow = n) # Matrice de variables latentes n*q
B <- c(0.5, 0.3, 1, 1.5, 1.2, 0.7)
C <- matrix(rnorm(p*q), nrow = p)
C <- C/sqrt(2*p)
XB <- VectorToMatrix(X%*%B, n, p)
Z <- XB + (W %*% t(C))
# Z <- scale(Z)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = c(Lambda)), nrow = n) # Matrice de comptage
print(max(Y))
O <- matrix(0, nrow = n, ncol = p)  # n*p
w <- rep(1,n)
params <- Initialisation(Y, X, q)
data <- list(Y = ifelse(is.na(Y), 0, 1), R = ifelse(is.na(Y), 0, 1), X = X, O = O, w = w)
config <- PLNPCA_param()$config_optim
res.PLNPCA <- Inter.PLNPCA(Y, X, O, w, q, params, config)
C.hat <- res.PLNPCA$estim$C
plot(C%*%t(C), C.hat%*%t(C.hat)); abline(0,1)
rm(list=ls())
1+1
#--------------------Libraries-----------------------
source(file = "Fonctions/Fonction_PLNPCA_covariables.R")
plot(1:6, 1:6)
quit()
rm(list=ls()); par(mfrow=c(1, 1), pch=20); palette('R3')
install.packages("devtools")
library("devtools")
install.packages("usethis")
(usethis)
library(usethis)
library("devtools")
getwd()
getwd()
setwd("~/colvR")
devtools::install()
devtools::load_all()
n <- 300
p <- 25
d <- 3
q <- 5
X <- cbind(c(rep(1, n*p)),matrix(rnorm(n*p*d), nrow = n*p))
B <- rnorm(d+1)
W <- matrix(rnorm(n*q), nrow = n)
C <- matrix(rnorm(p*q), nrow = p)/sqrt(q)
XB <- VectorToMatrix(X%*%B, n, p)
sum(diag(XB))
sum(diag(W%*%t(C)))
Z <- XB + W%*%t(C)
Lambda <- exp(Z)
Y <- matrix(rpois(n*p, lambda = Lambda), nrow = n)
Miss.ZIPLNPCA(Y, X, q)
Miss.ZIPLNPCA.logS(Y, X, q)
